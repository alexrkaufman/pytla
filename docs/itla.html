<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>itla.itla API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>itla.itla</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from time import sleep
import yaml
import serial
from scipy.constants import speed_of_light
from serial.serialutil import SerialException
from pkg_resources import resource_filename
from .itla_errors import *
from .utils import (setup_registers, form_packet,
                    compute_checksum)


regdoc = &#39;**Uses register {register:#04X}.**\n\n&#39;


class ITLA():
    &#39;&#39;&#39;
    A class that represents the an ITLA
    and exposes a user friendly API for controlling functionality.

    OIF-ITLA-MSA-01.3 is the standard implemented here.
    Certain functions such as set_frequency() dont fully implement this yet
    because I dont know how to do checks to see if the optional FCF3
    functions are implemented for a particular laser.

    Things to figure out

      * What should be exposed to the user?
      * Can we abstract away the concept of registers and stuff
        in here so you don&#39;t have to deal with it.

   There are some functions that could be implemented like set_fatalstatus.
   I think this is probably a bad idea even though it isnt write only.

   Set Frequency is my platonic ideal for the higher level functions.

    &#39;&#39;&#39;

    _nop_errors = {
        0x00: &#39;OK: No errors.&#39;,
        0x01: RNIError(&#39;RNI: Register not implemented.&#39;),
        0x02: RNWError(&#39;RNW: Register not writable&#39;),
        0x03: RVEError(&#39;RVE: Register Value range Error.&#39;),
        0x04: CIPError(&#39;CIP: Command Ignored due to Pending operation&#39;),
        0x05: CIIError(&#39;CII: Command Ignored Initializing&#39;),
        0x06: EREError(&#39;ERE: Extended address Range Error (address invalid)&#39;),
        0x07: EROError(&#39;ERO: Extended address is read only&#39;),
        0x08: EXFError(&#39;EXF: Execution general failure&#39;),
        0x09: CIEError(&#39;CIE: Command ignored while module\&#39;s optical output is enabled&#39;),
        0x0A: IVCError(&#39;IVC: Invalid configuration command ignored.&#39;),
        0x0F: VSEError(&#39;VSE: Vendor specific error&#39;)
    }

    _response_status = {
        0x00: &#39;OK&#39;,
        0x01: ExecutionError(&#39;Command returned execution error.&#39;),
        0x02: AEAException(&#39;AEA: automatic extended addressing &#39;
                           + &#39;being returned or ready to write.&#39;),
        0x03: CPException(&#39;CP: Command not complete, pending.&#39;)
    }

    def __init__(self, serial_port, baudrate, timeout=0.5,
                 register_files={&#39;registers_itla.yaml&#39;}):
        &#34;&#34;&#34;TODO describe function

        :param serial_port:
        :param baudrate:
        :param timeout:
        :returns:

        &#34;&#34;&#34;
        self._port = serial_port
        self._baudrate = baudrate
        self._timeout = timeout
        self._device = None

        # this function creates register functions
        def mkfn(*, fnname, register, description, readonly, signed, AEA):
            if readonly:
                def reg_fun(self):
                    self.send_command(register, signed=signed)
                    return self.get_response(register)

            else:
                def reg_fun(self, data=None):
                    self.send_command(register, data, signed=signed)
                    return self.get_response(register)

            reg_fun.__doc__ = description
            reg_fun.__name__ = fnname
            return reg_fun

        for register_file in register_files:
            register_file = resource_filename(&#39;itla&#39;, &#39;registers/&#39; + register_file)
            with open(register_file, &#39;r&#39;) as register_yaml:
                register_spec = yaml.safe_load(register_yaml)

                for register_name in register_spec:
                    register_data = register_spec[register_name]
                    setattr(ITLA,
                            &#39;_&#39; + register_data[&#39;fnname&#39;],
                            mkfn(**register_data))

    def __enter__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        self.connect()

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;TODO describe function

        :param exc_type:
        :param exc_value:
        :param traceback:
        :returns:

        &#34;&#34;&#34;
        self.disconnect()

    def __del__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        if self._device is not None:
            self.disconnect()

    def connect(self):
        &#34;&#34;&#34;Establishes a serial connection with the port provided

        **For some reason on Linux opening the serial port causes some
        power output from the laser before it has been activated. This behavior
        does not occur on Windows.**

        &#34;&#34;&#34;
        try:
            self._device = serial.Serial(self._port, self._baudrate,
                                         timeout=self._timeout)
        except SerialException:
            raise SerialException(&#34;Connection to &#34; + self._port + &#34; unsuccessful.&#34;)

    def disconnect(self, leave_on=False):
        &#34;&#34;&#34;Ends the serial connection to the laser

        :param leave_on:
        :returns:

        &#34;&#34;&#34;
        if not self._device.is_open:
            return

        if not leave_on:
            self.disable()

        try:
            self._device.close()
        except AttributeError:
            # When does this error occur?
            # There are a few ways disconnect can be called.
            # 1) It can be called purposefully.
            # 2) It can be called by ending a `with` (ie __exit__)
            # 3) It can be called by exiting a repl or a script ending (ie. __del__).
            pass

    def nop(self, data=None):
        &#34;&#34;&#34;TODO describe function

        :param data:
        :returns:

        &#34;&#34;&#34;
        # pretty sure the data does nothing
        if data is not None:
            response = self._nop(data)
        else:
            response = self._nop()

        error_field = int(response.hex()[-1], 16)
        if bool(error_field):
            raise self._nop_errors[error_field]

    def enable(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 3 SENA bit
        data[3] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        try:
            self._resena(data)
        except CPException:
            print(&#39;Waiting for laser to power on and stabilize.&#39;)
            # This would be a good place for a waiting function


    def disable(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # set SENA bit (bit 3) to zero
        data = [0] * 16
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)
        self._resena(data)

    def hard_reset(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 0: Module Reset
        data[0] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        self._resena(data)

    def soft_reset(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 1: Soft Reset
        data[1] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        self._resena(data)

    def get_device_type(self):
        &#34;&#34;&#34;
        returns a string containing the device type.
        &#34;&#34;&#34;
        response_bytes = self._devtyp()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_manufacturer(self):
        &#34;&#34;&#34;
        Return&#39;s a string containing the manufacturer&#39;s name.
        &#34;&#34;&#34;
        response_bytes = self._mfgr()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_model(self):
        &#34;&#34;&#34;
        return&#39;s the model as a string
        &#34;&#34;&#34;
        response_bytes = self._model()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_serialnumber(self):
        &#34;&#34;&#34;
        returns the serial number
        &#34;&#34;&#34;
        response_bytes = self._serno()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_manufacturing_date(self):
        &#34;&#34;&#34;returns the manufacturing date&#34;&#34;&#34;
        response_bytes = self._mfgdate()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_firmware_release(self):
        &#34;&#34;&#34;
        returns a manufacturer specific firmware release
        &#34;&#34;&#34;
        response_bytes = self._release()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_backwardscompatibility(self):
        &#34;&#34;&#34;
        returns a manufacturer specific firmware backwards compatibility
        as a null terminated string
        &#34;&#34;&#34;
        response_bytes = self._relback()

        return response_bytes.decode(&#39;utf-8&#39;)

    def read_aea(self):
        &#34;&#34;&#34;
        reads the AEA register data until an execution error is thrown.
        &#34;&#34;&#34;
        aea_response = b&#39;&#39;
        try:
            while True:
                aea_response += self._aea_ear()

        except ExecutionError as ee:

            try:
                self.nop()

            except EREError as eree:
                # If this throws an ERE error then we have completed reading AEA
                pass

            except NOPException as nop_e:
                raise nop_e

        return aea_response

    def set_power(self, pwr_dBm):
        &#34;&#34;&#34;Sets the power of the ITLA laser. Units of dBm.

        :param pwr_dBm: The power setting for the laser in dBm. Has precision XX.XX.
        :returns: None

        &#34;&#34;&#34;
        try:
            self._pwr(int(pwr_dBm * 100))

        except ExecutionError:

            try:
                self.nop()

            except RVEError as rvee:
                print(&#34;The provided power &#34; + str(pwr_dBm)
                      + &#34; is outside of the range for this device.&#34;)
                print(&#34;The power is currently set to: &#34;
                      + str(self.get_power_setting()))
                raise rvee

    def get_power_setting(self):
        &#34;&#34;&#34;Gets current power setting set by set_power. Should be in dBm.

        :returns:

        &#34;&#34;&#34;
        # Gets power setting, not actual optical output power.
        response = self._pwr()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_output(self):
        &#34;&#34;&#34;Gets the actual optical output power of the laser.
        Only an approximation, apparently. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._oop()

        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_min(self):
        &#34;&#34;&#34;Gets the minimum optical power output of the module. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._opsl()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_max(self):
        &#34;&#34;&#34;Gets the maximum optical power output of the module. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._opsh()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def set_fcf(self, freq):
        &#39;&#39;&#39;
        This sets the first channel frequency.
        It does not reset the channel so this frequency will only be equal
        to the output frequency if channel=1.

        &#39;&#39;&#39;
        # convert frequency to MHz
        freq = int(freq * 1e6)

        freq_str = str(freq)
        fcf1 = int(freq_str[0:3])
        fcf2 = int(freq_str[3:7])
        fcf3 = int(freq_str[7:])

        try:
            # is it better to split these into their own try/except blocks?
            self._fcf1(fcf1)
            self._fcf2(fcf2)
            self._fcf3(fcf3)

        except ExecutionError:
            try:
                self.nop()
            except RVEError as error:
                print(int(fcf1) + &#39;THz is out of bounds for this laser. &#39;)
                print(&#39;The frequency must be within the range, &#39;
                      + self.get_frequency_min() + &#39; - &#39;
                      + self.get_frequency_max() + &#39; THz.&#39;)
                raise error from None

            except CIEError as error:
                print(&#34;You cannot change the first channel frequency &#34;
                      + &#34;while the laser is enabled.&#34;)
                print(&#39;The current frequency is: &#39; + self.get_frequency() + &#39; THz&#39;)
                raise error from None

    def set_frequency(self, freq):
        &#34;&#34;&#34;Sets the frequency of the laser in TerraHertz.

        Has MHz resolution. Will round down.

        This function sets the first channel frequency and then sets the
        channel to 1 so that the frequency output when the laser is enabled
        will be the frequency given to this function.

        If you would like to only change the first channel frequency use
        the function `set_fcf`.

        :param freq: The desired frequency setting in THz.
        :returns: None

        &#34;&#34;&#34;

        self.set_fcf(freq)
        self.set_channel(1)

        # There needs to be some delay between this and setting channel.
        # even with some delay the CII error occurs from time to time. Fix.
        # This delay is way longer than i would like.
        # It would be ideal to have no sleeping necessary conditions.
        sleep(1)
        try:
            self.set_fine_tuning(0)

        except ExecutionError as ee:

            try:
                self.nop()

            except NOPException as nop_e:
                raise nop_e

        except CPException as cpe:
            print(&#39;Fine tuning takes some time. Waiting 5s.&#39;)
            sleep(5)


    def get_fcf(self):
        &#34;&#34;&#34; Get the currently set first channel frequency.
        &#34;&#34;&#34;
        response = self._fcf1()
        fcf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._fcf2()
        fcf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._fcf3()
        fcf3 = int.from_bytes(response, &#39;big&#39;)

        return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6

    def get_frequency(self):
        &#34;&#34;&#34;gets the current laser operating frequency with channels
        and everything accounted for.

        :returns:

        &#34;&#34;&#34;
        response = self._lf1()
        lf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lf2()
        lf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lf3()
        lf3 = int.from_bytes(response, &#39;big&#39;)

        return lf1 + lf2 * 1e-4 + lf3 * 1e-6

    def set_wavelength(self, wvl):
        &#34;&#34;&#34;Set the wavelength in nm. Converts wavelength to freq and calls set_frequency.

        :param wvl: The desired wavelength in nm.

        &#34;&#34;&#34;
        freq = (speed_of_light / (wvl * 1e-9)) * 1e-12  # get frequency in THz
        self.set_frequency(freq)
        raise Warning(&#39;There seems to be some roundoff error here. best to avoid this for now.&#39;)

    def dither_enable(self, waveform=&#39;sinusoidal&#39;):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if (waveform.lower() != &#39;sinusoid&#39;
            or waveform.lower() != &#39;triangular&#39;
              or waveform.lower() != &#39;sin&#39; or waveform.lower() != &#39;tri&#39;):

            raise ValueError(&#39;waveform must be \&#39;sinusoidal\&#39;, or \&#39;triangular\&#39;&#39;)

        pass

    def dither_disable(self):
        pass

    def set_dither_rate(self, rate):
        pass

    def set_dither_frequency(self, rate):
        pass

    def set_dither_amplitude(self, amplitude):
        pass

    def get_wavelength(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        pass

    def get_output_wavelength(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        pass

    def get_temp(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        response = self._ctemp()
        temp_100 = int.from_bytes(response, &#39;big&#39;)

        return temp_100 / 100

    def get_frequency_min(self):
        &#34;&#34;&#34;command to read minimum frequency supported by the module

        :returns:

        &#34;&#34;&#34;
        response = self._lfl1()
        lfl1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfl2()
        lfl2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfl3()
        lfl3 = int.from_bytes(response, &#39;big&#39;)

        return lfl1 + lfl2 * 1e-4 + lfl3 * 1e-6

    def get_frequency_max(self):
        &#34;&#34;&#34;command to read maximum frequency supported by the module

        :returns:

        &#34;&#34;&#34;
        response = self._lfh1()
        fcf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfh2()
        fcf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfh3()
        fcf3 = int.from_bytes(response, &#39;big&#39;)

        return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6

    def get_grid_min(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        try:
            self._lgrid()
            freq_lgrid = int(self._response[4:], 16)

            self._lgrid2()
            freq_lgrid2 = int(self._response[4:], 16)

        except ExecutionError as ee:
            self.nop()

        return freq_lgrid * 1e-1 + freq_lgrid2 * 1e-3

    def set_grid(self, grid_freq):
        &#34;&#34;&#34;Set the grid spacing in GHz.

        MHz resolution.

        :param grid_freq: the grid frequency spacing in GHz
        :returns:

        &#34;&#34;&#34;
        grid_freq = str(int(grid_freq * 1000))
        data = int(grid_freq[0:4])
        data_2 = int(grid_freq[4:])

        self._grid(data)
        self._grid2(data_2)

    def get_grid(self):
        &#34;&#34;&#34;get the grid spacing in GHz

        :returns: The grid spacing in GHz.

        &#34;&#34;&#34;
        response = self._grid()
        grid_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

        response = self._grid2()
        grid2_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

        return grid_freq * 1e-1 + grid2_freq * 1e-3

    def get_age(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        response = self._age()
        age = int.from_bytes(response, &#39;big&#39;)

        return f&#39;Age: {age} / 100%&#39;

    def set_channel(self, channel):
        &#34;&#34;&#34;TODO describe function

        :param channel:
        :returns:

        &#34;&#34;&#34;
        # check type and stuff
        if not isinstance(channel, int):
            raise TypeError(&#34;Channel must be an integer&#34;)
        if channel &lt; 0:
            raise ValueError(&#34;Channel must be positive.&#34;)
        if channel &gt; 0xFFFFFFFF:
            raise ValueError(&#34;Channel must be a 32 bit integer (&lt;=0xFFFFFFFF).&#34;)

        # Split the channel choice into two options.
        channel_hex = f&#39;{channel:08x}&#39;

        channell = int(channel_hex[4:], 16)
        channelh = int(channel_hex[0:4], 16)

        # Set the channel registers.
        self._channel(channell)
        self._channelh(channelh)

    def get_channel(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # This concatenates the data bytestrings
        response = self._channelh() + self._channel()

        channel = int.from_bytes(response, &#39;big&#39;)

        return channel

    def set_fine_tuning(self, ftf):
        &#34;&#34;&#34;
        This function provides off grid tuning for the laser&#39;s frequency.
        The adjustment applies to all channels uniformly.
        This is typically used after the laser if locked and minor adjustments
        are required to the frequency.

        The command may be pending in the event that the laser output is
        enabled. The pending bit is cleared once the fine tune frequency
        has been achieved.

        **???** It seems like this can be done with the laser running.

        :param ftf: The fine tune frequency adjustment in GHz
        &#34;&#34;&#34;

        ftf = int(ftf * 1e3)

        # We will leave this bare. This way the user can set and handle
        # their own timing and check to make sure the laser has reached the
        # desired fine tuning frequency.
        # It WILL throw a &#34;pending&#34; error if the laser is on when setting.
        self._ftf(ftf)

    def get_fine_tuning(self):
        &#34;&#34;&#34;
        This function returns the setting for the
        off grid tuning for the laser&#39;s frequency.

        :return ftf: The fine tune frequency adjustment in GHz
        &#34;&#34;&#34;

        response = self._ftf()
        ftf = int.from_bytes(response, &#39;big&#39;, signed=True)

        return ftf * 1e-3

    def send_command(self, register, data=None, signed=False):
        &#34;&#34;&#34;Sends commands to a device.
        This function takes the hexstring, turns it into a bytestring,
        and writes it to the device.
        This function should probably be hidden from the user.

        :param device: Should be a Serial object that you can write to.
        :param hexstring: a hexstring to send to the device
        :returns: nothing
        &#34;&#34;&#34;

        write = (data is not None)

        # convert to register to a bytestring
        register_bytes = register.to_bytes(1, &#39;big&#39;)

        # convert data to bytestring
        if write:
            data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

        else:
            data_bytes = (0).to_bytes(2, &#39;big&#39;)

        # compute the checksum
        checksum = compute_checksum(
            (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
            )

        # compute and convery header to bytestring
        header = checksum * 16 + write
        header_bytes = header.to_bytes(1, &#39;big&#39;)

        # form full command and send.
        command = header_bytes + register_bytes + data_bytes
        self._device.write(command)

    def get_response(self, register):
        &#34;&#34;&#34;This function should read from self._device. This should be called

        :param register:
        :returns: ???

        &#34;&#34;&#34;
        # read four bytes
        response = self._device.read(4)

        print(f&#39;response: {response.hex()}&#39;)

        # get the checksum and ... check it.
        checksum = int(response.hex()[0], 16)
        computed_checksum = compute_checksum(response.hex())

        if computed_checksum != checksum:
            raise Exception(f&#39;Communication error expected {checksum} got &#39;
                            + f&#39;{computed_checksum}&#39;)

        status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
        print(f&#39;status: {status}&#39;)

        try:
            raise self._response_status[status]

        except TypeError:
            # a type error occurs if we try to raise &#34;OK&#34;
            # in this situation we should just pass.
            pass

        except AEAException:
            response = self.read_aea()
            return response

        if register != response[1]:
            raise Exception(&#39;The returned register does not match &#39;
                            + &#39;the register sent to the device. &#39;
                            + f&#39;Got {response[1]} expected {register}.&#39;)

        return response[2:]

    def get_last_response(self):
        &#39;&#39;&#39;This function gets the most recent response sent from the laser.
        The response is parsed for errors and stuff the way any normal response
        would be. The variable `self._response` is set to the last response again.

        I dont know why you would need to do this.
        &#39;&#39;&#39;
        return self._lstresp()

    def upgrade_firmware(self, firmware_file):

        # STEPS:
        # 1) release
        # 2) set baudrate to 115200
        # 3) disconnect and reconnect at update baudrate
        # 4) send dlconfig signal
        # 5) ????
        # 6) profit
        pass</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="itla.itla.ITLA"><code class="flex name class">
<span>class <span class="ident">ITLA</span></span>
<span>(</span><span>serial_port, baudrate, timeout=0.5, register_files={'registers_itla.yaml'})</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents the an ITLA
and exposes a user friendly API for controlling functionality.</p>
<p>OIF-ITLA-MSA-01.3 is the standard implemented here.
Certain functions such as set_frequency() dont fully implement this yet
because I dont know how to do checks to see if the optional FCF3
functions are implemented for a particular laser.</p>
<p>Things to figure out</p>
<ul>
<li>What should be exposed to the user?</li>
<li>Can we abstract away the concept of registers and stuff
in here so you don't have to deal with it.</li>
</ul>
<p>There are some functions that could be implemented like set_fatalstatus.
I think this is probably a bad idea even though it isnt write only.</p>
<p>Set Frequency is my platonic ideal for the higher level functions.</p>
<p>TODO describe function</p>
<p>:param serial_port:
:param baudrate:
:param timeout:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ITLA():
    &#39;&#39;&#39;
    A class that represents the an ITLA
    and exposes a user friendly API for controlling functionality.

    OIF-ITLA-MSA-01.3 is the standard implemented here.
    Certain functions such as set_frequency() dont fully implement this yet
    because I dont know how to do checks to see if the optional FCF3
    functions are implemented for a particular laser.

    Things to figure out

      * What should be exposed to the user?
      * Can we abstract away the concept of registers and stuff
        in here so you don&#39;t have to deal with it.

   There are some functions that could be implemented like set_fatalstatus.
   I think this is probably a bad idea even though it isnt write only.

   Set Frequency is my platonic ideal for the higher level functions.

    &#39;&#39;&#39;

    _nop_errors = {
        0x00: &#39;OK: No errors.&#39;,
        0x01: RNIError(&#39;RNI: Register not implemented.&#39;),
        0x02: RNWError(&#39;RNW: Register not writable&#39;),
        0x03: RVEError(&#39;RVE: Register Value range Error.&#39;),
        0x04: CIPError(&#39;CIP: Command Ignored due to Pending operation&#39;),
        0x05: CIIError(&#39;CII: Command Ignored Initializing&#39;),
        0x06: EREError(&#39;ERE: Extended address Range Error (address invalid)&#39;),
        0x07: EROError(&#39;ERO: Extended address is read only&#39;),
        0x08: EXFError(&#39;EXF: Execution general failure&#39;),
        0x09: CIEError(&#39;CIE: Command ignored while module\&#39;s optical output is enabled&#39;),
        0x0A: IVCError(&#39;IVC: Invalid configuration command ignored.&#39;),
        0x0F: VSEError(&#39;VSE: Vendor specific error&#39;)
    }

    _response_status = {
        0x00: &#39;OK&#39;,
        0x01: ExecutionError(&#39;Command returned execution error.&#39;),
        0x02: AEAException(&#39;AEA: automatic extended addressing &#39;
                           + &#39;being returned or ready to write.&#39;),
        0x03: CPException(&#39;CP: Command not complete, pending.&#39;)
    }

    def __init__(self, serial_port, baudrate, timeout=0.5,
                 register_files={&#39;registers_itla.yaml&#39;}):
        &#34;&#34;&#34;TODO describe function

        :param serial_port:
        :param baudrate:
        :param timeout:
        :returns:

        &#34;&#34;&#34;
        self._port = serial_port
        self._baudrate = baudrate
        self._timeout = timeout
        self._device = None

        # this function creates register functions
        def mkfn(*, fnname, register, description, readonly, signed, AEA):
            if readonly:
                def reg_fun(self):
                    self.send_command(register, signed=signed)
                    return self.get_response(register)

            else:
                def reg_fun(self, data=None):
                    self.send_command(register, data, signed=signed)
                    return self.get_response(register)

            reg_fun.__doc__ = description
            reg_fun.__name__ = fnname
            return reg_fun

        for register_file in register_files:
            register_file = resource_filename(&#39;itla&#39;, &#39;registers/&#39; + register_file)
            with open(register_file, &#39;r&#39;) as register_yaml:
                register_spec = yaml.safe_load(register_yaml)

                for register_name in register_spec:
                    register_data = register_spec[register_name]
                    setattr(ITLA,
                            &#39;_&#39; + register_data[&#39;fnname&#39;],
                            mkfn(**register_data))

    def __enter__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        self.connect()

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;TODO describe function

        :param exc_type:
        :param exc_value:
        :param traceback:
        :returns:

        &#34;&#34;&#34;
        self.disconnect()

    def __del__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        if self._device is not None:
            self.disconnect()

    def connect(self):
        &#34;&#34;&#34;Establishes a serial connection with the port provided

        **For some reason on Linux opening the serial port causes some
        power output from the laser before it has been activated. This behavior
        does not occur on Windows.**

        &#34;&#34;&#34;
        try:
            self._device = serial.Serial(self._port, self._baudrate,
                                         timeout=self._timeout)
        except SerialException:
            raise SerialException(&#34;Connection to &#34; + self._port + &#34; unsuccessful.&#34;)

    def disconnect(self, leave_on=False):
        &#34;&#34;&#34;Ends the serial connection to the laser

        :param leave_on:
        :returns:

        &#34;&#34;&#34;
        if not self._device.is_open:
            return

        if not leave_on:
            self.disable()

        try:
            self._device.close()
        except AttributeError:
            # When does this error occur?
            # There are a few ways disconnect can be called.
            # 1) It can be called purposefully.
            # 2) It can be called by ending a `with` (ie __exit__)
            # 3) It can be called by exiting a repl or a script ending (ie. __del__).
            pass

    def nop(self, data=None):
        &#34;&#34;&#34;TODO describe function

        :param data:
        :returns:

        &#34;&#34;&#34;
        # pretty sure the data does nothing
        if data is not None:
            response = self._nop(data)
        else:
            response = self._nop()

        error_field = int(response.hex()[-1], 16)
        if bool(error_field):
            raise self._nop_errors[error_field]

    def enable(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 3 SENA bit
        data[3] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        try:
            self._resena(data)
        except CPException:
            print(&#39;Waiting for laser to power on and stabilize.&#39;)
            # This would be a good place for a waiting function


    def disable(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # set SENA bit (bit 3) to zero
        data = [0] * 16
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)
        self._resena(data)

    def hard_reset(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 0: Module Reset
        data[0] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        self._resena(data)

    def soft_reset(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # I&#39;m writing this out partially for transparency
        # Maybe unnecessary or non-optimal
        data = [0] * 16
        # bit 1: Soft Reset
        data[1] = 1
        data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

        self._resena(data)

    def get_device_type(self):
        &#34;&#34;&#34;
        returns a string containing the device type.
        &#34;&#34;&#34;
        response_bytes = self._devtyp()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_manufacturer(self):
        &#34;&#34;&#34;
        Return&#39;s a string containing the manufacturer&#39;s name.
        &#34;&#34;&#34;
        response_bytes = self._mfgr()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_model(self):
        &#34;&#34;&#34;
        return&#39;s the model as a string
        &#34;&#34;&#34;
        response_bytes = self._model()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_serialnumber(self):
        &#34;&#34;&#34;
        returns the serial number
        &#34;&#34;&#34;
        response_bytes = self._serno()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_manufacturing_date(self):
        &#34;&#34;&#34;returns the manufacturing date&#34;&#34;&#34;
        response_bytes = self._mfgdate()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_firmware_release(self):
        &#34;&#34;&#34;
        returns a manufacturer specific firmware release
        &#34;&#34;&#34;
        response_bytes = self._release()

        return response_bytes.decode(&#39;utf-8&#39;)

    def get_backwardscompatibility(self):
        &#34;&#34;&#34;
        returns a manufacturer specific firmware backwards compatibility
        as a null terminated string
        &#34;&#34;&#34;
        response_bytes = self._relback()

        return response_bytes.decode(&#39;utf-8&#39;)

    def read_aea(self):
        &#34;&#34;&#34;
        reads the AEA register data until an execution error is thrown.
        &#34;&#34;&#34;
        aea_response = b&#39;&#39;
        try:
            while True:
                aea_response += self._aea_ear()

        except ExecutionError as ee:

            try:
                self.nop()

            except EREError as eree:
                # If this throws an ERE error then we have completed reading AEA
                pass

            except NOPException as nop_e:
                raise nop_e

        return aea_response

    def set_power(self, pwr_dBm):
        &#34;&#34;&#34;Sets the power of the ITLA laser. Units of dBm.

        :param pwr_dBm: The power setting for the laser in dBm. Has precision XX.XX.
        :returns: None

        &#34;&#34;&#34;
        try:
            self._pwr(int(pwr_dBm * 100))

        except ExecutionError:

            try:
                self.nop()

            except RVEError as rvee:
                print(&#34;The provided power &#34; + str(pwr_dBm)
                      + &#34; is outside of the range for this device.&#34;)
                print(&#34;The power is currently set to: &#34;
                      + str(self.get_power_setting()))
                raise rvee

    def get_power_setting(self):
        &#34;&#34;&#34;Gets current power setting set by set_power. Should be in dBm.

        :returns:

        &#34;&#34;&#34;
        # Gets power setting, not actual optical output power.
        response = self._pwr()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_output(self):
        &#34;&#34;&#34;Gets the actual optical output power of the laser.
        Only an approximation, apparently. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._oop()

        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_min(self):
        &#34;&#34;&#34;Gets the minimum optical power output of the module. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._opsl()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def get_power_max(self):
        &#34;&#34;&#34;Gets the maximum optical power output of the module. Units dBm.

        :returns:

        &#34;&#34;&#34;
        response = self._opsh()
        return int.from_bytes(response, &#39;big&#39;, signed=True) / 100

    def set_fcf(self, freq):
        &#39;&#39;&#39;
        This sets the first channel frequency.
        It does not reset the channel so this frequency will only be equal
        to the output frequency if channel=1.

        &#39;&#39;&#39;
        # convert frequency to MHz
        freq = int(freq * 1e6)

        freq_str = str(freq)
        fcf1 = int(freq_str[0:3])
        fcf2 = int(freq_str[3:7])
        fcf3 = int(freq_str[7:])

        try:
            # is it better to split these into their own try/except blocks?
            self._fcf1(fcf1)
            self._fcf2(fcf2)
            self._fcf3(fcf3)

        except ExecutionError:
            try:
                self.nop()
            except RVEError as error:
                print(int(fcf1) + &#39;THz is out of bounds for this laser. &#39;)
                print(&#39;The frequency must be within the range, &#39;
                      + self.get_frequency_min() + &#39; - &#39;
                      + self.get_frequency_max() + &#39; THz.&#39;)
                raise error from None

            except CIEError as error:
                print(&#34;You cannot change the first channel frequency &#34;
                      + &#34;while the laser is enabled.&#34;)
                print(&#39;The current frequency is: &#39; + self.get_frequency() + &#39; THz&#39;)
                raise error from None

    def set_frequency(self, freq):
        &#34;&#34;&#34;Sets the frequency of the laser in TerraHertz.

        Has MHz resolution. Will round down.

        This function sets the first channel frequency and then sets the
        channel to 1 so that the frequency output when the laser is enabled
        will be the frequency given to this function.

        If you would like to only change the first channel frequency use
        the function `set_fcf`.

        :param freq: The desired frequency setting in THz.
        :returns: None

        &#34;&#34;&#34;

        self.set_fcf(freq)
        self.set_channel(1)

        # There needs to be some delay between this and setting channel.
        # even with some delay the CII error occurs from time to time. Fix.
        # This delay is way longer than i would like.
        # It would be ideal to have no sleeping necessary conditions.
        sleep(1)
        try:
            self.set_fine_tuning(0)

        except ExecutionError as ee:

            try:
                self.nop()

            except NOPException as nop_e:
                raise nop_e

        except CPException as cpe:
            print(&#39;Fine tuning takes some time. Waiting 5s.&#39;)
            sleep(5)


    def get_fcf(self):
        &#34;&#34;&#34; Get the currently set first channel frequency.
        &#34;&#34;&#34;
        response = self._fcf1()
        fcf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._fcf2()
        fcf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._fcf3()
        fcf3 = int.from_bytes(response, &#39;big&#39;)

        return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6

    def get_frequency(self):
        &#34;&#34;&#34;gets the current laser operating frequency with channels
        and everything accounted for.

        :returns:

        &#34;&#34;&#34;
        response = self._lf1()
        lf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lf2()
        lf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lf3()
        lf3 = int.from_bytes(response, &#39;big&#39;)

        return lf1 + lf2 * 1e-4 + lf3 * 1e-6

    def set_wavelength(self, wvl):
        &#34;&#34;&#34;Set the wavelength in nm. Converts wavelength to freq and calls set_frequency.

        :param wvl: The desired wavelength in nm.

        &#34;&#34;&#34;
        freq = (speed_of_light / (wvl * 1e-9)) * 1e-12  # get frequency in THz
        self.set_frequency(freq)
        raise Warning(&#39;There seems to be some roundoff error here. best to avoid this for now.&#39;)

    def dither_enable(self, waveform=&#39;sinusoidal&#39;):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if (waveform.lower() != &#39;sinusoid&#39;
            or waveform.lower() != &#39;triangular&#39;
              or waveform.lower() != &#39;sin&#39; or waveform.lower() != &#39;tri&#39;):

            raise ValueError(&#39;waveform must be \&#39;sinusoidal\&#39;, or \&#39;triangular\&#39;&#39;)

        pass

    def dither_disable(self):
        pass

    def set_dither_rate(self, rate):
        pass

    def set_dither_frequency(self, rate):
        pass

    def set_dither_amplitude(self, amplitude):
        pass

    def get_wavelength(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        pass

    def get_output_wavelength(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        pass

    def get_temp(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        response = self._ctemp()
        temp_100 = int.from_bytes(response, &#39;big&#39;)

        return temp_100 / 100

    def get_frequency_min(self):
        &#34;&#34;&#34;command to read minimum frequency supported by the module

        :returns:

        &#34;&#34;&#34;
        response = self._lfl1()
        lfl1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfl2()
        lfl2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfl3()
        lfl3 = int.from_bytes(response, &#39;big&#39;)

        return lfl1 + lfl2 * 1e-4 + lfl3 * 1e-6

    def get_frequency_max(self):
        &#34;&#34;&#34;command to read maximum frequency supported by the module

        :returns:

        &#34;&#34;&#34;
        response = self._lfh1()
        fcf1 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfh2()
        fcf2 = int.from_bytes(response, &#39;big&#39;)

        response = self._lfh3()
        fcf3 = int.from_bytes(response, &#39;big&#39;)

        return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6

    def get_grid_min(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        try:
            self._lgrid()
            freq_lgrid = int(self._response[4:], 16)

            self._lgrid2()
            freq_lgrid2 = int(self._response[4:], 16)

        except ExecutionError as ee:
            self.nop()

        return freq_lgrid * 1e-1 + freq_lgrid2 * 1e-3

    def set_grid(self, grid_freq):
        &#34;&#34;&#34;Set the grid spacing in GHz.

        MHz resolution.

        :param grid_freq: the grid frequency spacing in GHz
        :returns:

        &#34;&#34;&#34;
        grid_freq = str(int(grid_freq * 1000))
        data = int(grid_freq[0:4])
        data_2 = int(grid_freq[4:])

        self._grid(data)
        self._grid2(data_2)

    def get_grid(self):
        &#34;&#34;&#34;get the grid spacing in GHz

        :returns: The grid spacing in GHz.

        &#34;&#34;&#34;
        response = self._grid()
        grid_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

        response = self._grid2()
        grid2_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

        return grid_freq * 1e-1 + grid2_freq * 1e-3

    def get_age(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        response = self._age()
        age = int.from_bytes(response, &#39;big&#39;)

        return f&#39;Age: {age} / 100%&#39;

    def set_channel(self, channel):
        &#34;&#34;&#34;TODO describe function

        :param channel:
        :returns:

        &#34;&#34;&#34;
        # check type and stuff
        if not isinstance(channel, int):
            raise TypeError(&#34;Channel must be an integer&#34;)
        if channel &lt; 0:
            raise ValueError(&#34;Channel must be positive.&#34;)
        if channel &gt; 0xFFFFFFFF:
            raise ValueError(&#34;Channel must be a 32 bit integer (&lt;=0xFFFFFFFF).&#34;)

        # Split the channel choice into two options.
        channel_hex = f&#39;{channel:08x}&#39;

        channell = int(channel_hex[4:], 16)
        channelh = int(channel_hex[0:4], 16)

        # Set the channel registers.
        self._channel(channell)
        self._channelh(channelh)

    def get_channel(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        # This concatenates the data bytestrings
        response = self._channelh() + self._channel()

        channel = int.from_bytes(response, &#39;big&#39;)

        return channel

    def set_fine_tuning(self, ftf):
        &#34;&#34;&#34;
        This function provides off grid tuning for the laser&#39;s frequency.
        The adjustment applies to all channels uniformly.
        This is typically used after the laser if locked and minor adjustments
        are required to the frequency.

        The command may be pending in the event that the laser output is
        enabled. The pending bit is cleared once the fine tune frequency
        has been achieved.

        **???** It seems like this can be done with the laser running.

        :param ftf: The fine tune frequency adjustment in GHz
        &#34;&#34;&#34;

        ftf = int(ftf * 1e3)

        # We will leave this bare. This way the user can set and handle
        # their own timing and check to make sure the laser has reached the
        # desired fine tuning frequency.
        # It WILL throw a &#34;pending&#34; error if the laser is on when setting.
        self._ftf(ftf)

    def get_fine_tuning(self):
        &#34;&#34;&#34;
        This function returns the setting for the
        off grid tuning for the laser&#39;s frequency.

        :return ftf: The fine tune frequency adjustment in GHz
        &#34;&#34;&#34;

        response = self._ftf()
        ftf = int.from_bytes(response, &#39;big&#39;, signed=True)

        return ftf * 1e-3

    def send_command(self, register, data=None, signed=False):
        &#34;&#34;&#34;Sends commands to a device.
        This function takes the hexstring, turns it into a bytestring,
        and writes it to the device.
        This function should probably be hidden from the user.

        :param device: Should be a Serial object that you can write to.
        :param hexstring: a hexstring to send to the device
        :returns: nothing
        &#34;&#34;&#34;

        write = (data is not None)

        # convert to register to a bytestring
        register_bytes = register.to_bytes(1, &#39;big&#39;)

        # convert data to bytestring
        if write:
            data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

        else:
            data_bytes = (0).to_bytes(2, &#39;big&#39;)

        # compute the checksum
        checksum = compute_checksum(
            (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
            )

        # compute and convery header to bytestring
        header = checksum * 16 + write
        header_bytes = header.to_bytes(1, &#39;big&#39;)

        # form full command and send.
        command = header_bytes + register_bytes + data_bytes
        self._device.write(command)

    def get_response(self, register):
        &#34;&#34;&#34;This function should read from self._device. This should be called

        :param register:
        :returns: ???

        &#34;&#34;&#34;
        # read four bytes
        response = self._device.read(4)

        print(f&#39;response: {response.hex()}&#39;)

        # get the checksum and ... check it.
        checksum = int(response.hex()[0], 16)
        computed_checksum = compute_checksum(response.hex())

        if computed_checksum != checksum:
            raise Exception(f&#39;Communication error expected {checksum} got &#39;
                            + f&#39;{computed_checksum}&#39;)

        status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
        print(f&#39;status: {status}&#39;)

        try:
            raise self._response_status[status]

        except TypeError:
            # a type error occurs if we try to raise &#34;OK&#34;
            # in this situation we should just pass.
            pass

        except AEAException:
            response = self.read_aea()
            return response

        if register != response[1]:
            raise Exception(&#39;The returned register does not match &#39;
                            + &#39;the register sent to the device. &#39;
                            + f&#39;Got {response[1]} expected {register}.&#39;)

        return response[2:]

    def get_last_response(self):
        &#39;&#39;&#39;This function gets the most recent response sent from the laser.
        The response is parsed for errors and stuff the way any normal response
        would be. The variable `self._response` is set to the last response again.

        I dont know why you would need to do this.
        &#39;&#39;&#39;
        return self._lstresp()

    def upgrade_firmware(self, firmware_file):

        # STEPS:
        # 1) release
        # 2) set baudrate to 115200
        # 3) disconnect and reconnect at update baudrate
        # 4) send dlconfig signal
        # 5) ????
        # 6) profit
        pass</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="itla.itla.ITLA.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Establishes a serial connection with the port provided</p>
<p><strong>For some reason on Linux opening the serial port causes some
power output from the laser before it has been activated. This behavior
does not occur on Windows.</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Establishes a serial connection with the port provided

    **For some reason on Linux opening the serial port causes some
    power output from the laser before it has been activated. This behavior
    does not occur on Windows.**

    &#34;&#34;&#34;
    try:
        self._device = serial.Serial(self._port, self._baudrate,
                                     timeout=self._timeout)
    except SerialException:
        raise SerialException(&#34;Connection to &#34; + self._port + &#34; unsuccessful.&#34;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.disable"><code class="name flex">
<span>def <span class="ident">disable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    # set SENA bit (bit 3) to zero
    data = [0] * 16
    data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)
    self._resena(data)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, leave_on=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends the serial connection to the laser</p>
<p>:param leave_on:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, leave_on=False):
    &#34;&#34;&#34;Ends the serial connection to the laser

    :param leave_on:
    :returns:

    &#34;&#34;&#34;
    if not self._device.is_open:
        return

    if not leave_on:
        self.disable()

    try:
        self._device.close()
    except AttributeError:
        # When does this error occur?
        # There are a few ways disconnect can be called.
        # 1) It can be called purposefully.
        # 2) It can be called by ending a `with` (ie __exit__)
        # 3) It can be called by exiting a repl or a script ending (ie. __del__).
        pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.dither_disable"><code class="name flex">
<span>def <span class="ident">dither_disable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dither_disable(self):
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.dither_enable"><code class="name flex">
<span>def <span class="ident">dither_enable</span></span>(<span>self, waveform='sinusoidal')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dither_enable(self, waveform=&#39;sinusoidal&#39;):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    if (waveform.lower() != &#39;sinusoid&#39;
        or waveform.lower() != &#39;triangular&#39;
          or waveform.lower() != &#39;sin&#39; or waveform.lower() != &#39;tri&#39;):

        raise ValueError(&#39;waveform must be \&#39;sinusoidal\&#39;, or \&#39;triangular\&#39;&#39;)

    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.enable"><code class="name flex">
<span>def <span class="ident">enable</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    # I&#39;m writing this out partially for transparency
    # Maybe unnecessary or non-optimal
    data = [0] * 16
    # bit 3 SENA bit
    data[3] = 1
    data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

    try:
        self._resena(data)
    except CPException:
        print(&#39;Waiting for laser to power on and stabilize.&#39;)
        # This would be a good place for a waiting function</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_age"><code class="name flex">
<span>def <span class="ident">get_age</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_age(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    response = self._age()
    age = int.from_bytes(response, &#39;big&#39;)

    return f&#39;Age: {age} / 100%&#39;</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_backwardscompatibility"><code class="name flex">
<span>def <span class="ident">get_backwardscompatibility</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a manufacturer specific firmware backwards compatibility
as a null terminated string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_backwardscompatibility(self):
    &#34;&#34;&#34;
    returns a manufacturer specific firmware backwards compatibility
    as a null terminated string
    &#34;&#34;&#34;
    response_bytes = self._relback()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_channel"><code class="name flex">
<span>def <span class="ident">get_channel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    # This concatenates the data bytestrings
    response = self._channelh() + self._channel()

    channel = int.from_bytes(response, &#39;big&#39;)

    return channel</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_device_type"><code class="name flex">
<span>def <span class="ident">get_device_type</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a string containing the device type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_type(self):
    &#34;&#34;&#34;
    returns a string containing the device type.
    &#34;&#34;&#34;
    response_bytes = self._devtyp()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_fcf"><code class="name flex">
<span>def <span class="ident">get_fcf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the currently set first channel frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fcf(self):
    &#34;&#34;&#34; Get the currently set first channel frequency.
    &#34;&#34;&#34;
    response = self._fcf1()
    fcf1 = int.from_bytes(response, &#39;big&#39;)

    response = self._fcf2()
    fcf2 = int.from_bytes(response, &#39;big&#39;)

    response = self._fcf3()
    fcf3 = int.from_bytes(response, &#39;big&#39;)

    return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_fine_tuning"><code class="name flex">
<span>def <span class="ident">get_fine_tuning</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function returns the setting for the
off grid tuning for the laser's frequency.</p>
<p>:return ftf: The fine tune frequency adjustment in GHz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fine_tuning(self):
    &#34;&#34;&#34;
    This function returns the setting for the
    off grid tuning for the laser&#39;s frequency.

    :return ftf: The fine tune frequency adjustment in GHz
    &#34;&#34;&#34;

    response = self._ftf()
    ftf = int.from_bytes(response, &#39;big&#39;, signed=True)

    return ftf * 1e-3</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_firmware_release"><code class="name flex">
<span>def <span class="ident">get_firmware_release</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a manufacturer specific firmware release</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_firmware_release(self):
    &#34;&#34;&#34;
    returns a manufacturer specific firmware release
    &#34;&#34;&#34;
    response_bytes = self._release()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_frequency"><code class="name flex">
<span>def <span class="ident">get_frequency</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>gets the current laser operating frequency with channels
and everything accounted for.</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency(self):
    &#34;&#34;&#34;gets the current laser operating frequency with channels
    and everything accounted for.

    :returns:

    &#34;&#34;&#34;
    response = self._lf1()
    lf1 = int.from_bytes(response, &#39;big&#39;)

    response = self._lf2()
    lf2 = int.from_bytes(response, &#39;big&#39;)

    response = self._lf3()
    lf3 = int.from_bytes(response, &#39;big&#39;)

    return lf1 + lf2 * 1e-4 + lf3 * 1e-6</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_frequency_max"><code class="name flex">
<span>def <span class="ident">get_frequency_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>command to read maximum frequency supported by the module</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_max(self):
    &#34;&#34;&#34;command to read maximum frequency supported by the module

    :returns:

    &#34;&#34;&#34;
    response = self._lfh1()
    fcf1 = int.from_bytes(response, &#39;big&#39;)

    response = self._lfh2()
    fcf2 = int.from_bytes(response, &#39;big&#39;)

    response = self._lfh3()
    fcf3 = int.from_bytes(response, &#39;big&#39;)

    return fcf1 + fcf2 * 1e-4 + fcf3 * 1e-6</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_frequency_min"><code class="name flex">
<span>def <span class="ident">get_frequency_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>command to read minimum frequency supported by the module</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_frequency_min(self):
    &#34;&#34;&#34;command to read minimum frequency supported by the module

    :returns:

    &#34;&#34;&#34;
    response = self._lfl1()
    lfl1 = int.from_bytes(response, &#39;big&#39;)

    response = self._lfl2()
    lfl2 = int.from_bytes(response, &#39;big&#39;)

    response = self._lfl3()
    lfl3 = int.from_bytes(response, &#39;big&#39;)

    return lfl1 + lfl2 * 1e-4 + lfl3 * 1e-6</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_grid"><code class="name flex">
<span>def <span class="ident">get_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>get the grid spacing in GHz</p>
<p>:returns: The grid spacing in GHz.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid(self):
    &#34;&#34;&#34;get the grid spacing in GHz

    :returns: The grid spacing in GHz.

    &#34;&#34;&#34;
    response = self._grid()
    grid_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

    response = self._grid2()
    grid2_freq = int.from_bytes(response, &#39;big&#39;, signed=True)

    return grid_freq * 1e-1 + grid2_freq * 1e-3</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_grid_min"><code class="name flex">
<span>def <span class="ident">get_grid_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_grid_min(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    try:
        self._lgrid()
        freq_lgrid = int(self._response[4:], 16)

        self._lgrid2()
        freq_lgrid2 = int(self._response[4:], 16)

    except ExecutionError as ee:
        self.nop()

    return freq_lgrid * 1e-1 + freq_lgrid2 * 1e-3</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_last_response"><code class="name flex">
<span>def <span class="ident">get_last_response</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This function gets the most recent response sent from the laser.
The response is parsed for errors and stuff the way any normal response
would be. The variable <code>self._response</code> is set to the last response again.</p>
<p>I dont know why you would need to do this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_last_response(self):
    &#39;&#39;&#39;This function gets the most recent response sent from the laser.
    The response is parsed for errors and stuff the way any normal response
    would be. The variable `self._response` is set to the last response again.

    I dont know why you would need to do this.
    &#39;&#39;&#39;
    return self._lstresp()</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_manufacturer"><code class="name flex">
<span>def <span class="ident">get_manufacturer</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return's a string containing the manufacturer's name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_manufacturer(self):
    &#34;&#34;&#34;
    Return&#39;s a string containing the manufacturer&#39;s name.
    &#34;&#34;&#34;
    response_bytes = self._mfgr()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_manufacturing_date"><code class="name flex">
<span>def <span class="ident">get_manufacturing_date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the manufacturing date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_manufacturing_date(self):
    &#34;&#34;&#34;returns the manufacturing date&#34;&#34;&#34;
    response_bytes = self._mfgdate()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return's the model as a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self):
    &#34;&#34;&#34;
    return&#39;s the model as a string
    &#34;&#34;&#34;
    response_bytes = self._model()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_output_wavelength"><code class="name flex">
<span>def <span class="ident">get_output_wavelength</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_wavelength(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_power_max"><code class="name flex">
<span>def <span class="ident">get_power_max</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the maximum optical power output of the module. Units dBm.</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_max(self):
    &#34;&#34;&#34;Gets the maximum optical power output of the module. Units dBm.

    :returns:

    &#34;&#34;&#34;
    response = self._opsh()
    return int.from_bytes(response, &#39;big&#39;, signed=True) / 100</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_power_min"><code class="name flex">
<span>def <span class="ident">get_power_min</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the minimum optical power output of the module. Units dBm.</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_min(self):
    &#34;&#34;&#34;Gets the minimum optical power output of the module. Units dBm.

    :returns:

    &#34;&#34;&#34;
    response = self._opsl()
    return int.from_bytes(response, &#39;big&#39;, signed=True) / 100</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_power_output"><code class="name flex">
<span>def <span class="ident">get_power_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the actual optical output power of the laser.
Only an approximation, apparently. Units dBm.</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_output(self):
    &#34;&#34;&#34;Gets the actual optical output power of the laser.
    Only an approximation, apparently. Units dBm.

    :returns:

    &#34;&#34;&#34;
    response = self._oop()

    return int.from_bytes(response, &#39;big&#39;, signed=True) / 100</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_power_setting"><code class="name flex">
<span>def <span class="ident">get_power_setting</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets current power setting set by set_power. Should be in dBm.</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_setting(self):
    &#34;&#34;&#34;Gets current power setting set by set_power. Should be in dBm.

    :returns:

    &#34;&#34;&#34;
    # Gets power setting, not actual optical output power.
    response = self._pwr()
    return int.from_bytes(response, &#39;big&#39;, signed=True) / 100</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_response"><code class="name flex">
<span>def <span class="ident">get_response</span></span>(<span>self, register)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should read from self._device. This should be called</p>
<p>:param register:
:returns: ???</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_response(self, register):
    &#34;&#34;&#34;This function should read from self._device. This should be called

    :param register:
    :returns: ???

    &#34;&#34;&#34;
    # read four bytes
    response = self._device.read(4)

    print(f&#39;response: {response.hex()}&#39;)

    # get the checksum and ... check it.
    checksum = int(response.hex()[0], 16)
    computed_checksum = compute_checksum(response.hex())

    if computed_checksum != checksum:
        raise Exception(f&#39;Communication error expected {checksum} got &#39;
                        + f&#39;{computed_checksum}&#39;)

    status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
    print(f&#39;status: {status}&#39;)

    try:
        raise self._response_status[status]

    except TypeError:
        # a type error occurs if we try to raise &#34;OK&#34;
        # in this situation we should just pass.
        pass

    except AEAException:
        response = self.read_aea()
        return response

    if register != response[1]:
        raise Exception(&#39;The returned register does not match &#39;
                        + &#39;the register sent to the device. &#39;
                        + f&#39;Got {response[1]} expected {register}.&#39;)

    return response[2:]</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_serialnumber"><code class="name flex">
<span>def <span class="ident">get_serialnumber</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the serial number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_serialnumber(self):
    &#34;&#34;&#34;
    returns the serial number
    &#34;&#34;&#34;
    response_bytes = self._serno()

    return response_bytes.decode(&#39;utf-8&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_temp"><code class="name flex">
<span>def <span class="ident">get_temp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_temp(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    response = self._ctemp()
    temp_100 = int.from_bytes(response, &#39;big&#39;)

    return temp_100 / 100</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.get_wavelength"><code class="name flex">
<span>def <span class="ident">get_wavelength</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wavelength(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.hard_reset"><code class="name flex">
<span>def <span class="ident">hard_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hard_reset(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    # I&#39;m writing this out partially for transparency
    # Maybe unnecessary or non-optimal
    data = [0] * 16
    # bit 0: Module Reset
    data[0] = 1
    data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

    self._resena(data)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.nop"><code class="name flex">
<span>def <span class="ident">nop</span></span>(<span>self, data=None)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:param data:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nop(self, data=None):
    &#34;&#34;&#34;TODO describe function

    :param data:
    :returns:

    &#34;&#34;&#34;
    # pretty sure the data does nothing
    if data is not None:
        response = self._nop(data)
    else:
        response = self._nop()

    error_field = int(response.hex()[-1], 16)
    if bool(error_field):
        raise self._nop_errors[error_field]</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.read_aea"><code class="name flex">
<span>def <span class="ident">read_aea</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>reads the AEA register data until an execution error is thrown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_aea(self):
    &#34;&#34;&#34;
    reads the AEA register data until an execution error is thrown.
    &#34;&#34;&#34;
    aea_response = b&#39;&#39;
    try:
        while True:
            aea_response += self._aea_ear()

    except ExecutionError as ee:

        try:
            self.nop()

        except EREError as eree:
            # If this throws an ERE error then we have completed reading AEA
            pass

        except NOPException as nop_e:
            raise nop_e

    return aea_response</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, register, data=None, signed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends commands to a device.
This function takes the hexstring, turns it into a bytestring,
and writes it to the device.
This function should probably be hidden from the user.</p>
<p>:param device: Should be a Serial object that you can write to.
:param hexstring: a hexstring to send to the device
:returns: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(self, register, data=None, signed=False):
    &#34;&#34;&#34;Sends commands to a device.
    This function takes the hexstring, turns it into a bytestring,
    and writes it to the device.
    This function should probably be hidden from the user.

    :param device: Should be a Serial object that you can write to.
    :param hexstring: a hexstring to send to the device
    :returns: nothing
    &#34;&#34;&#34;

    write = (data is not None)

    # convert to register to a bytestring
    register_bytes = register.to_bytes(1, &#39;big&#39;)

    # convert data to bytestring
    if write:
        data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

    else:
        data_bytes = (0).to_bytes(2, &#39;big&#39;)

    # compute the checksum
    checksum = compute_checksum(
        (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
        )

    # compute and convery header to bytestring
    header = checksum * 16 + write
    header_bytes = header.to_bytes(1, &#39;big&#39;)

    # form full command and send.
    command = header_bytes + register_bytes + data_bytes
    self._device.write(command)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_channel"><code class="name flex">
<span>def <span class="ident">set_channel</span></span>(<span>self, channel)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:param channel:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_channel(self, channel):
    &#34;&#34;&#34;TODO describe function

    :param channel:
    :returns:

    &#34;&#34;&#34;
    # check type and stuff
    if not isinstance(channel, int):
        raise TypeError(&#34;Channel must be an integer&#34;)
    if channel &lt; 0:
        raise ValueError(&#34;Channel must be positive.&#34;)
    if channel &gt; 0xFFFFFFFF:
        raise ValueError(&#34;Channel must be a 32 bit integer (&lt;=0xFFFFFFFF).&#34;)

    # Split the channel choice into two options.
    channel_hex = f&#39;{channel:08x}&#39;

    channell = int(channel_hex[4:], 16)
    channelh = int(channel_hex[0:4], 16)

    # Set the channel registers.
    self._channel(channell)
    self._channelh(channelh)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_dither_amplitude"><code class="name flex">
<span>def <span class="ident">set_dither_amplitude</span></span>(<span>self, amplitude)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dither_amplitude(self, amplitude):
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_dither_frequency"><code class="name flex">
<span>def <span class="ident">set_dither_frequency</span></span>(<span>self, rate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dither_frequency(self, rate):
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_dither_rate"><code class="name flex">
<span>def <span class="ident">set_dither_rate</span></span>(<span>self, rate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_dither_rate(self, rate):
    pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_fcf"><code class="name flex">
<span>def <span class="ident">set_fcf</span></span>(<span>self, freq)</span>
</code></dt>
<dd>
<div class="desc"><p>This sets the first channel frequency.
It does not reset the channel so this frequency will only be equal
to the output frequency if channel=1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fcf(self, freq):
    &#39;&#39;&#39;
    This sets the first channel frequency.
    It does not reset the channel so this frequency will only be equal
    to the output frequency if channel=1.

    &#39;&#39;&#39;
    # convert frequency to MHz
    freq = int(freq * 1e6)

    freq_str = str(freq)
    fcf1 = int(freq_str[0:3])
    fcf2 = int(freq_str[3:7])
    fcf3 = int(freq_str[7:])

    try:
        # is it better to split these into their own try/except blocks?
        self._fcf1(fcf1)
        self._fcf2(fcf2)
        self._fcf3(fcf3)

    except ExecutionError:
        try:
            self.nop()
        except RVEError as error:
            print(int(fcf1) + &#39;THz is out of bounds for this laser. &#39;)
            print(&#39;The frequency must be within the range, &#39;
                  + self.get_frequency_min() + &#39; - &#39;
                  + self.get_frequency_max() + &#39; THz.&#39;)
            raise error from None

        except CIEError as error:
            print(&#34;You cannot change the first channel frequency &#34;
                  + &#34;while the laser is enabled.&#34;)
            print(&#39;The current frequency is: &#39; + self.get_frequency() + &#39; THz&#39;)
            raise error from None</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_fine_tuning"><code class="name flex">
<span>def <span class="ident">set_fine_tuning</span></span>(<span>self, ftf)</span>
</code></dt>
<dd>
<div class="desc"><p>This function provides off grid tuning for the laser's frequency.
The adjustment applies to all channels uniformly.
This is typically used after the laser if locked and minor adjustments
are required to the frequency.</p>
<p>The command may be pending in the event that the laser output is
enabled. The pending bit is cleared once the fine tune frequency
has been achieved.</p>
<p><strong>???</strong> It seems like this can be done with the laser running.</p>
<p>:param ftf: The fine tune frequency adjustment in GHz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_fine_tuning(self, ftf):
    &#34;&#34;&#34;
    This function provides off grid tuning for the laser&#39;s frequency.
    The adjustment applies to all channels uniformly.
    This is typically used after the laser if locked and minor adjustments
    are required to the frequency.

    The command may be pending in the event that the laser output is
    enabled. The pending bit is cleared once the fine tune frequency
    has been achieved.

    **???** It seems like this can be done with the laser running.

    :param ftf: The fine tune frequency adjustment in GHz
    &#34;&#34;&#34;

    ftf = int(ftf * 1e3)

    # We will leave this bare. This way the user can set and handle
    # their own timing and check to make sure the laser has reached the
    # desired fine tuning frequency.
    # It WILL throw a &#34;pending&#34; error if the laser is on when setting.
    self._ftf(ftf)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_frequency"><code class="name flex">
<span>def <span class="ident">set_frequency</span></span>(<span>self, freq)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the frequency of the laser in TerraHertz.</p>
<p>Has MHz resolution. Will round down.</p>
<p>This function sets the first channel frequency and then sets the
channel to 1 so that the frequency output when the laser is enabled
will be the frequency given to this function.</p>
<p>If you would like to only change the first channel frequency use
the function <code>set_fcf</code>.</p>
<p>:param freq: The desired frequency setting in THz.
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_frequency(self, freq):
    &#34;&#34;&#34;Sets the frequency of the laser in TerraHertz.

    Has MHz resolution. Will round down.

    This function sets the first channel frequency and then sets the
    channel to 1 so that the frequency output when the laser is enabled
    will be the frequency given to this function.

    If you would like to only change the first channel frequency use
    the function `set_fcf`.

    :param freq: The desired frequency setting in THz.
    :returns: None

    &#34;&#34;&#34;

    self.set_fcf(freq)
    self.set_channel(1)

    # There needs to be some delay between this and setting channel.
    # even with some delay the CII error occurs from time to time. Fix.
    # This delay is way longer than i would like.
    # It would be ideal to have no sleeping necessary conditions.
    sleep(1)
    try:
        self.set_fine_tuning(0)

    except ExecutionError as ee:

        try:
            self.nop()

        except NOPException as nop_e:
            raise nop_e

    except CPException as cpe:
        print(&#39;Fine tuning takes some time. Waiting 5s.&#39;)
        sleep(5)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_grid"><code class="name flex">
<span>def <span class="ident">set_grid</span></span>(<span>self, grid_freq)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the grid spacing in GHz.</p>
<p>MHz resolution.</p>
<p>:param grid_freq: the grid frequency spacing in GHz
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_grid(self, grid_freq):
    &#34;&#34;&#34;Set the grid spacing in GHz.

    MHz resolution.

    :param grid_freq: the grid frequency spacing in GHz
    :returns:

    &#34;&#34;&#34;
    grid_freq = str(int(grid_freq * 1000))
    data = int(grid_freq[0:4])
    data_2 = int(grid_freq[4:])

    self._grid(data)
    self._grid2(data_2)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_power"><code class="name flex">
<span>def <span class="ident">set_power</span></span>(<span>self, pwr_dBm)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the power of the ITLA laser. Units of dBm.</p>
<p>:param pwr_dBm: The power setting for the laser in dBm. Has precision XX.XX.
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_power(self, pwr_dBm):
    &#34;&#34;&#34;Sets the power of the ITLA laser. Units of dBm.

    :param pwr_dBm: The power setting for the laser in dBm. Has precision XX.XX.
    :returns: None

    &#34;&#34;&#34;
    try:
        self._pwr(int(pwr_dBm * 100))

    except ExecutionError:

        try:
            self.nop()

        except RVEError as rvee:
            print(&#34;The provided power &#34; + str(pwr_dBm)
                  + &#34; is outside of the range for this device.&#34;)
            print(&#34;The power is currently set to: &#34;
                  + str(self.get_power_setting()))
            raise rvee</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.set_wavelength"><code class="name flex">
<span>def <span class="ident">set_wavelength</span></span>(<span>self, wvl)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the wavelength in nm. Converts wavelength to freq and calls set_frequency.</p>
<p>:param wvl: The desired wavelength in nm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_wavelength(self, wvl):
    &#34;&#34;&#34;Set the wavelength in nm. Converts wavelength to freq and calls set_frequency.

    :param wvl: The desired wavelength in nm.

    &#34;&#34;&#34;
    freq = (speed_of_light / (wvl * 1e-9)) * 1e-12  # get frequency in THz
    self.set_frequency(freq)
    raise Warning(&#39;There seems to be some roundoff error here. best to avoid this for now.&#39;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.soft_reset"><code class="name flex">
<span>def <span class="ident">soft_reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO describe function</p>
<p>:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def soft_reset(self):
    &#34;&#34;&#34;TODO describe function

    :returns:

    &#34;&#34;&#34;
    # I&#39;m writing this out partially for transparency
    # Maybe unnecessary or non-optimal
    data = [0] * 16
    # bit 1: Soft Reset
    data[1] = 1
    data = int(&#39;&#39;.join(str(x) for x in data[::-1]), 2)

    self._resena(data)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLA.upgrade_firmware"><code class="name flex">
<span>def <span class="ident">upgrade_firmware</span></span>(<span>self, firmware_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upgrade_firmware(self, firmware_file):

    # STEPS:
    # 1) release
    # 2) set baudrate to 115200
    # 3) disconnect and reconnect at update baudrate
    # 4) send dlconfig signal
    # 5) ????
    # 6) profit
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="itla" href="index.html">itla</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="itla.itla.ITLA" href="#itla.itla.ITLA">ITLA</a></code></h4>
<ul class="">
<li><code><a title="itla.itla.ITLA.connect" href="#itla.itla.ITLA.connect">connect</a></code></li>
<li><code><a title="itla.itla.ITLA.disable" href="#itla.itla.ITLA.disable">disable</a></code></li>
<li><code><a title="itla.itla.ITLA.disconnect" href="#itla.itla.ITLA.disconnect">disconnect</a></code></li>
<li><code><a title="itla.itla.ITLA.dither_disable" href="#itla.itla.ITLA.dither_disable">dither_disable</a></code></li>
<li><code><a title="itla.itla.ITLA.dither_enable" href="#itla.itla.ITLA.dither_enable">dither_enable</a></code></li>
<li><code><a title="itla.itla.ITLA.enable" href="#itla.itla.ITLA.enable">enable</a></code></li>
<li><code><a title="itla.itla.ITLA.get_age" href="#itla.itla.ITLA.get_age">get_age</a></code></li>
<li><code><a title="itla.itla.ITLA.get_backwardscompatibility" href="#itla.itla.ITLA.get_backwardscompatibility">get_backwardscompatibility</a></code></li>
<li><code><a title="itla.itla.ITLA.get_channel" href="#itla.itla.ITLA.get_channel">get_channel</a></code></li>
<li><code><a title="itla.itla.ITLA.get_device_type" href="#itla.itla.ITLA.get_device_type">get_device_type</a></code></li>
<li><code><a title="itla.itla.ITLA.get_fcf" href="#itla.itla.ITLA.get_fcf">get_fcf</a></code></li>
<li><code><a title="itla.itla.ITLA.get_fine_tuning" href="#itla.itla.ITLA.get_fine_tuning">get_fine_tuning</a></code></li>
<li><code><a title="itla.itla.ITLA.get_firmware_release" href="#itla.itla.ITLA.get_firmware_release">get_firmware_release</a></code></li>
<li><code><a title="itla.itla.ITLA.get_frequency" href="#itla.itla.ITLA.get_frequency">get_frequency</a></code></li>
<li><code><a title="itla.itla.ITLA.get_frequency_max" href="#itla.itla.ITLA.get_frequency_max">get_frequency_max</a></code></li>
<li><code><a title="itla.itla.ITLA.get_frequency_min" href="#itla.itla.ITLA.get_frequency_min">get_frequency_min</a></code></li>
<li><code><a title="itla.itla.ITLA.get_grid" href="#itla.itla.ITLA.get_grid">get_grid</a></code></li>
<li><code><a title="itla.itla.ITLA.get_grid_min" href="#itla.itla.ITLA.get_grid_min">get_grid_min</a></code></li>
<li><code><a title="itla.itla.ITLA.get_last_response" href="#itla.itla.ITLA.get_last_response">get_last_response</a></code></li>
<li><code><a title="itla.itla.ITLA.get_manufacturer" href="#itla.itla.ITLA.get_manufacturer">get_manufacturer</a></code></li>
<li><code><a title="itla.itla.ITLA.get_manufacturing_date" href="#itla.itla.ITLA.get_manufacturing_date">get_manufacturing_date</a></code></li>
<li><code><a title="itla.itla.ITLA.get_model" href="#itla.itla.ITLA.get_model">get_model</a></code></li>
<li><code><a title="itla.itla.ITLA.get_output_wavelength" href="#itla.itla.ITLA.get_output_wavelength">get_output_wavelength</a></code></li>
<li><code><a title="itla.itla.ITLA.get_power_max" href="#itla.itla.ITLA.get_power_max">get_power_max</a></code></li>
<li><code><a title="itla.itla.ITLA.get_power_min" href="#itla.itla.ITLA.get_power_min">get_power_min</a></code></li>
<li><code><a title="itla.itla.ITLA.get_power_output" href="#itla.itla.ITLA.get_power_output">get_power_output</a></code></li>
<li><code><a title="itla.itla.ITLA.get_power_setting" href="#itla.itla.ITLA.get_power_setting">get_power_setting</a></code></li>
<li><code><a title="itla.itla.ITLA.get_response" href="#itla.itla.ITLA.get_response">get_response</a></code></li>
<li><code><a title="itla.itla.ITLA.get_serialnumber" href="#itla.itla.ITLA.get_serialnumber">get_serialnumber</a></code></li>
<li><code><a title="itla.itla.ITLA.get_temp" href="#itla.itla.ITLA.get_temp">get_temp</a></code></li>
<li><code><a title="itla.itla.ITLA.get_wavelength" href="#itla.itla.ITLA.get_wavelength">get_wavelength</a></code></li>
<li><code><a title="itla.itla.ITLA.hard_reset" href="#itla.itla.ITLA.hard_reset">hard_reset</a></code></li>
<li><code><a title="itla.itla.ITLA.nop" href="#itla.itla.ITLA.nop">nop</a></code></li>
<li><code><a title="itla.itla.ITLA.read_aea" href="#itla.itla.ITLA.read_aea">read_aea</a></code></li>
<li><code><a title="itla.itla.ITLA.send_command" href="#itla.itla.ITLA.send_command">send_command</a></code></li>
<li><code><a title="itla.itla.ITLA.set_channel" href="#itla.itla.ITLA.set_channel">set_channel</a></code></li>
<li><code><a title="itla.itla.ITLA.set_dither_amplitude" href="#itla.itla.ITLA.set_dither_amplitude">set_dither_amplitude</a></code></li>
<li><code><a title="itla.itla.ITLA.set_dither_frequency" href="#itla.itla.ITLA.set_dither_frequency">set_dither_frequency</a></code></li>
<li><code><a title="itla.itla.ITLA.set_dither_rate" href="#itla.itla.ITLA.set_dither_rate">set_dither_rate</a></code></li>
<li><code><a title="itla.itla.ITLA.set_fcf" href="#itla.itla.ITLA.set_fcf">set_fcf</a></code></li>
<li><code><a title="itla.itla.ITLA.set_fine_tuning" href="#itla.itla.ITLA.set_fine_tuning">set_fine_tuning</a></code></li>
<li><code><a title="itla.itla.ITLA.set_frequency" href="#itla.itla.ITLA.set_frequency">set_frequency</a></code></li>
<li><code><a title="itla.itla.ITLA.set_grid" href="#itla.itla.ITLA.set_grid">set_grid</a></code></li>
<li><code><a title="itla.itla.ITLA.set_power" href="#itla.itla.ITLA.set_power">set_power</a></code></li>
<li><code><a title="itla.itla.ITLA.set_wavelength" href="#itla.itla.ITLA.set_wavelength">set_wavelength</a></code></li>
<li><code><a title="itla.itla.ITLA.soft_reset" href="#itla.itla.ITLA.soft_reset">soft_reset</a></code></li>
<li><code><a title="itla.itla.ITLA.upgrade_firmware" href="#itla.itla.ITLA.upgrade_firmware">upgrade_firmware</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>