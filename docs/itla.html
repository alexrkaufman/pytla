<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>itla.itla API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>itla.itla</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from pkg_resources import resource_filename
from .itla_errors import *
from .utils import compute_checksum
import yaml
import serial
from serial.serialutil import SerialException


class ITLABase():
    &#39;&#39;&#39;
    A class that represents the an ITLA
    and exposes a user friendly API for controlling functionality.

    Things to figure out

      * What should be exposed to the user?
      * Can we abstract away the concept of registers and stuff
        in here so you don&#39;t have to deal with it.

    There are some functions that could be implemented like set_fatalstatus.
    I think this is probably a bad idea even though it isnt write only.

    set_frequency is my platonic ideal for the higher level functions.
    &#39;&#39;&#39;

    _nop_errors = {
        0x00: &#39;OK: No errors.&#39;,
        0x01: RNIError(&#39;RNI: Register not implemented.&#39;),
        0x02: RNWError(&#39;RNW: Register not writable&#39;),
        0x03: RVEError(&#39;RVE: Register Value range Error.&#39;),
        0x04: CIPError(&#39;CIP: Command Ignored due to Pending operation&#39;),
        0x05: CIIError(&#39;CII: Command Ignored Initializing&#39;),
        0x06: EREError(&#39;ERE: Extended address Range Error (address invalid)&#39;),
        0x07: EROError(&#39;ERO: Extended address is read only&#39;),
        0x08: EXFError(&#39;EXF: Execution general failure&#39;),
        0x09: CIEError(&#39;CIE: Command ignored while module\&#39;s optical output is enabled&#39;),
        0x0A: IVCError(&#39;IVC: Invalid configuration command ignored.&#39;),
        0x0F: VSEError(&#39;VSE: Vendor specific error&#39;)
    }

    _response_status = {
        0x00: &#39;OK&#39;,
        0x01: ExecutionError(&#39;Command returned execution error.&#39;),
        0x02: AEAException(&#39;AEA: automatic extended addressing &#39;
                           + &#39;being returned or ready to write.&#39;),
        0x03: CPException(&#39;CP: Command not complete, pending.&#39;)
    }

    def __init__(self, serial_port, baudrate, timeout=0.5,
                 register_files=None):
        &#34;&#34;&#34;TODO describe function

        :param serial_port:
        :param baudrate:
        :param timeout:
        :returns:

        &#34;&#34;&#34;
        self._port = serial_port
        self._baudrate = baudrate
        self._timeout = timeout
        self._device = None

        if register_files is None:
            register_files = []

        # this function creates register functions
        def mkfn(*, fnname, register, description,
                 readonly, signed, **_):
            # _ here to absorb unused things. This way the yaml
            # can contain more info without causing errors here.
            if readonly:
                def reg_fun(self):
                    self.send_command(register, signed=signed)
                    return self.get_response(register)

            else:
                def reg_fun(self, data=None):
                    self.send_command(register, data, signed=signed)
                    return self.get_response(register)

            reg_fun.__doc__ = description
            reg_fun.__name__ = fnname
            return reg_fun

        for register_file in register_files:
            register_file = resource_filename(&#39;itla&#39;,
                                              &#39;registers/&#39; + register_file)
            with open(register_file, &#39;r&#39;) as register_yaml:
                register_spec = yaml.safe_load(register_yaml)

                for register_name in register_spec:
                    register_data = register_spec[register_name]
                    setattr(ITLABase,
                            &#39;_&#39; + register_data[&#39;fnname&#39;],
                            mkfn(**register_data))

    def __enter__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        self.connect()

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;TODO describe function

        :param exc_type:
        :param exc_value:
        :param traceback:
        :returns:

        &#34;&#34;&#34;
        self.disconnect()

    def __del__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        if self._device is not None:
            self.disconnect()

    def connect(self):
        &#34;&#34;&#34;Establishes a serial connection with the port provided

        **For some reason on Linux opening the serial port causes some
        power output from the laser before it has been activated. This behavior
        does not occur on Windows.**

        &#34;&#34;&#34;
        try:
            self._device = serial.Serial(self._port, self._baudrate,
                                         timeout=self._timeout)
        except SerialException:
            raise SerialException(&#34;Connection to &#34;
                                  + self._port + &#34; unsuccessful.&#34;)

    def disconnect(self, leave_on=False):
        &#34;&#34;&#34;Ends the serial connection to the laser

        :param leave_on:
        :returns:

        &#34;&#34;&#34;
        if not self._device.is_open:
            return

        if not leave_on:
            self.disable()

        try:
            self._device.close()
        except AttributeError:
            # When does this error occur?
            # There are a few ways disconnect can be called.
            # 1) It can be called purposefully.
            # 2) It can be called by ending a `with` (ie __exit__)
            # 3) It can be called by exiting a repl or a script ending (ie. __del__).
            pass

    def send_command(self, register, data=None, signed=False):
        &#34;&#34;&#34;Sends commands to a device.
        This function takes the hexstring, turns it into a bytestring,
        and writes it to the device.
        This function should probably be hidden from the user.

        :param device: Should be a Serial object that you can write to.
        :param hexstring: a hexstring to send to the device
        :returns: nothing
        &#34;&#34;&#34;

        write = (data is not None)

        # convert to register to a bytestring
        register_bytes = register.to_bytes(1, &#39;big&#39;)

        # convert data to bytestring
        if write:
            data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

        else:
            data_bytes = (0).to_bytes(2, &#39;big&#39;)

        # compute the checksum
        checksum = compute_checksum(
            (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
        )

        # compute and convery header to bytestring
        header = checksum * 16 + write
        header_bytes = header.to_bytes(1, &#39;big&#39;)

        # form full command and send.
        command = header_bytes + register_bytes + data_bytes
        self._device.write(command)

    def get_response(self, register):
        &#34;&#34;&#34;This function should read from self._device. This should be called

        :param register:
        :returns: ???

        &#34;&#34;&#34;
        # read four bytes
        response = self._device.read(4)

        print(f&#39;response: {response.hex()}&#39;)

        # get the checksum and ... check it.
        checksum = int(response.hex()[0], 16)
        computed_checksum = compute_checksum(response.hex())

        if computed_checksum != checksum:
            raise Exception(f&#39;Communication error expected {checksum} got &#39;
                            + f&#39;{computed_checksum}&#39;)

        status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
        print(f&#39;status: {status}&#39;)

        try:
            raise self._response_status[status]

        except TypeError:
            # a type error occurs if we try to raise &#34;OK&#34;
            # in this situation we should just pass.
            pass

        except AEAException:
            response = self.read_aea()
            return response

        if register != response[1]:
            raise Exception(&#39;The returned register does not match &#39;
                            + &#39;the register sent to the device. &#39;
                            + f&#39;Got {response[1]} expected {register}.&#39;)

        return response[2:]

    def upgrade_firmware(self, firmware_file):
        &#34;&#34;&#34; This function should update the firmware for the laser.
        &#34;&#34;&#34;

        # STEPS:
        # 1) release
        # 2) set baudrate to 115200
        # 3) disconnect and reconnect at update baudrate
        # 4) send dlconfig signal
        # 5) ????
        # 6) profit
        raise Warning(&#34;this is not implemented yet.&#34;)


class ITLA():
    &#39;&#39;&#39;
    The class that users should interface and create ITLA objects from.
    Basically just used to select the appropriate subclass of ITLABase.
    &#39;&#39;&#39;

    def __new__(cls, *args, version=&#39;1.3&#39;, **kwargs):
        &#39;&#39;&#39;
        this function is executed on initialization of an object before
        __init__ here we divert the initialization process to initialize
        one of the subclasses of ITLABase.

        I would love it if there were a way to make everything a
        subclass of ITLA and merge the ITLA and ITLABase classes.
        This would streamline some things and make it easier to do type
        checking since it only makes sense that all ITLA laser objects would
        be subclasses of ITLA not some random arbitrary ITLABase.

        The current issue in doing this is that we end up with a circular import.
        &#39;&#39;&#39;
        from .itla12 import ITLA12
        from .itla13 import ITLA13

        class_dict = {
            &#39;1.3&#39;: ITLA13,
            &#39;1.2&#39;: ITLA12,
        }

        return class_dict[version](*args, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="itla.itla.ITLA"><code class="flex name class">
<span>class <span class="ident">ITLA</span></span>
<span>(</span><span>*args, version='1.3', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The class that users should interface and create ITLA objects from.
Basically just used to select the appropriate subclass of ITLABase.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ITLA():
    &#39;&#39;&#39;
    The class that users should interface and create ITLA objects from.
    Basically just used to select the appropriate subclass of ITLABase.
    &#39;&#39;&#39;

    def __new__(cls, *args, version=&#39;1.3&#39;, **kwargs):
        &#39;&#39;&#39;
        this function is executed on initialization of an object before
        __init__ here we divert the initialization process to initialize
        one of the subclasses of ITLABase.

        I would love it if there were a way to make everything a
        subclass of ITLA and merge the ITLA and ITLABase classes.
        This would streamline some things and make it easier to do type
        checking since it only makes sense that all ITLA laser objects would
        be subclasses of ITLA not some random arbitrary ITLABase.

        The current issue in doing this is that we end up with a circular import.
        &#39;&#39;&#39;
        from .itla12 import ITLA12
        from .itla13 import ITLA13

        class_dict = {
            &#39;1.3&#39;: ITLA13,
            &#39;1.2&#39;: ITLA12,
        }

        return class_dict[version](*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLABase"><code class="flex name class">
<span>class <span class="ident">ITLABase</span></span>
<span>(</span><span>serial_port, baudrate, timeout=0.5, register_files=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents the an ITLA
and exposes a user friendly API for controlling functionality.</p>
<p>Things to figure out</p>
<ul>
<li>What should be exposed to the user?</li>
<li>Can we abstract away the concept of registers and stuff
in here so you don't have to deal with it.</li>
</ul>
<p>There are some functions that could be implemented like set_fatalstatus.
I think this is probably a bad idea even though it isnt write only.</p>
<p>set_frequency is my platonic ideal for the higher level functions.</p>
<p>TODO describe function</p>
<p>:param serial_port:
:param baudrate:
:param timeout:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ITLABase():
    &#39;&#39;&#39;
    A class that represents the an ITLA
    and exposes a user friendly API for controlling functionality.

    Things to figure out

      * What should be exposed to the user?
      * Can we abstract away the concept of registers and stuff
        in here so you don&#39;t have to deal with it.

    There are some functions that could be implemented like set_fatalstatus.
    I think this is probably a bad idea even though it isnt write only.

    set_frequency is my platonic ideal for the higher level functions.
    &#39;&#39;&#39;

    _nop_errors = {
        0x00: &#39;OK: No errors.&#39;,
        0x01: RNIError(&#39;RNI: Register not implemented.&#39;),
        0x02: RNWError(&#39;RNW: Register not writable&#39;),
        0x03: RVEError(&#39;RVE: Register Value range Error.&#39;),
        0x04: CIPError(&#39;CIP: Command Ignored due to Pending operation&#39;),
        0x05: CIIError(&#39;CII: Command Ignored Initializing&#39;),
        0x06: EREError(&#39;ERE: Extended address Range Error (address invalid)&#39;),
        0x07: EROError(&#39;ERO: Extended address is read only&#39;),
        0x08: EXFError(&#39;EXF: Execution general failure&#39;),
        0x09: CIEError(&#39;CIE: Command ignored while module\&#39;s optical output is enabled&#39;),
        0x0A: IVCError(&#39;IVC: Invalid configuration command ignored.&#39;),
        0x0F: VSEError(&#39;VSE: Vendor specific error&#39;)
    }

    _response_status = {
        0x00: &#39;OK&#39;,
        0x01: ExecutionError(&#39;Command returned execution error.&#39;),
        0x02: AEAException(&#39;AEA: automatic extended addressing &#39;
                           + &#39;being returned or ready to write.&#39;),
        0x03: CPException(&#39;CP: Command not complete, pending.&#39;)
    }

    def __init__(self, serial_port, baudrate, timeout=0.5,
                 register_files=None):
        &#34;&#34;&#34;TODO describe function

        :param serial_port:
        :param baudrate:
        :param timeout:
        :returns:

        &#34;&#34;&#34;
        self._port = serial_port
        self._baudrate = baudrate
        self._timeout = timeout
        self._device = None

        if register_files is None:
            register_files = []

        # this function creates register functions
        def mkfn(*, fnname, register, description,
                 readonly, signed, **_):
            # _ here to absorb unused things. This way the yaml
            # can contain more info without causing errors here.
            if readonly:
                def reg_fun(self):
                    self.send_command(register, signed=signed)
                    return self.get_response(register)

            else:
                def reg_fun(self, data=None):
                    self.send_command(register, data, signed=signed)
                    return self.get_response(register)

            reg_fun.__doc__ = description
            reg_fun.__name__ = fnname
            return reg_fun

        for register_file in register_files:
            register_file = resource_filename(&#39;itla&#39;,
                                              &#39;registers/&#39; + register_file)
            with open(register_file, &#39;r&#39;) as register_yaml:
                register_spec = yaml.safe_load(register_yaml)

                for register_name in register_spec:
                    register_data = register_spec[register_name]
                    setattr(ITLABase,
                            &#39;_&#39; + register_data[&#39;fnname&#39;],
                            mkfn(**register_data))

    def __enter__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        self.connect()

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;TODO describe function

        :param exc_type:
        :param exc_value:
        :param traceback:
        :returns:

        &#34;&#34;&#34;
        self.disconnect()

    def __del__(self):
        &#34;&#34;&#34;TODO describe function

        :returns:

        &#34;&#34;&#34;
        if self._device is not None:
            self.disconnect()

    def connect(self):
        &#34;&#34;&#34;Establishes a serial connection with the port provided

        **For some reason on Linux opening the serial port causes some
        power output from the laser before it has been activated. This behavior
        does not occur on Windows.**

        &#34;&#34;&#34;
        try:
            self._device = serial.Serial(self._port, self._baudrate,
                                         timeout=self._timeout)
        except SerialException:
            raise SerialException(&#34;Connection to &#34;
                                  + self._port + &#34; unsuccessful.&#34;)

    def disconnect(self, leave_on=False):
        &#34;&#34;&#34;Ends the serial connection to the laser

        :param leave_on:
        :returns:

        &#34;&#34;&#34;
        if not self._device.is_open:
            return

        if not leave_on:
            self.disable()

        try:
            self._device.close()
        except AttributeError:
            # When does this error occur?
            # There are a few ways disconnect can be called.
            # 1) It can be called purposefully.
            # 2) It can be called by ending a `with` (ie __exit__)
            # 3) It can be called by exiting a repl or a script ending (ie. __del__).
            pass

    def send_command(self, register, data=None, signed=False):
        &#34;&#34;&#34;Sends commands to a device.
        This function takes the hexstring, turns it into a bytestring,
        and writes it to the device.
        This function should probably be hidden from the user.

        :param device: Should be a Serial object that you can write to.
        :param hexstring: a hexstring to send to the device
        :returns: nothing
        &#34;&#34;&#34;

        write = (data is not None)

        # convert to register to a bytestring
        register_bytes = register.to_bytes(1, &#39;big&#39;)

        # convert data to bytestring
        if write:
            data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

        else:
            data_bytes = (0).to_bytes(2, &#39;big&#39;)

        # compute the checksum
        checksum = compute_checksum(
            (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
        )

        # compute and convery header to bytestring
        header = checksum * 16 + write
        header_bytes = header.to_bytes(1, &#39;big&#39;)

        # form full command and send.
        command = header_bytes + register_bytes + data_bytes
        self._device.write(command)

    def get_response(self, register):
        &#34;&#34;&#34;This function should read from self._device. This should be called

        :param register:
        :returns: ???

        &#34;&#34;&#34;
        # read four bytes
        response = self._device.read(4)

        print(f&#39;response: {response.hex()}&#39;)

        # get the checksum and ... check it.
        checksum = int(response.hex()[0], 16)
        computed_checksum = compute_checksum(response.hex())

        if computed_checksum != checksum:
            raise Exception(f&#39;Communication error expected {checksum} got &#39;
                            + f&#39;{computed_checksum}&#39;)

        status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
        print(f&#39;status: {status}&#39;)

        try:
            raise self._response_status[status]

        except TypeError:
            # a type error occurs if we try to raise &#34;OK&#34;
            # in this situation we should just pass.
            pass

        except AEAException:
            response = self.read_aea()
            return response

        if register != response[1]:
            raise Exception(&#39;The returned register does not match &#39;
                            + &#39;the register sent to the device. &#39;
                            + f&#39;Got {response[1]} expected {register}.&#39;)

        return response[2:]

    def upgrade_firmware(self, firmware_file):
        &#34;&#34;&#34; This function should update the firmware for the laser.
        &#34;&#34;&#34;

        # STEPS:
        # 1) release
        # 2) set baudrate to 115200
        # 3) disconnect and reconnect at update baudrate
        # 4) send dlconfig signal
        # 5) ????
        # 6) profit
        raise Warning(&#34;this is not implemented yet.&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="itla.itla12.ITLA12" href="itla12.html#itla.itla12.ITLA12">ITLA12</a></li>
<li><a title="itla.itla13.ITLA13" href="itla13.html#itla.itla13.ITLA13">ITLA13</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="itla.itla.ITLABase.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Establishes a serial connection with the port provided</p>
<p><strong>For some reason on Linux opening the serial port causes some
power output from the laser before it has been activated. This behavior
does not occur on Windows.</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(self):
    &#34;&#34;&#34;Establishes a serial connection with the port provided

    **For some reason on Linux opening the serial port causes some
    power output from the laser before it has been activated. This behavior
    does not occur on Windows.**

    &#34;&#34;&#34;
    try:
        self._device = serial.Serial(self._port, self._baudrate,
                                     timeout=self._timeout)
    except SerialException:
        raise SerialException(&#34;Connection to &#34;
                              + self._port + &#34; unsuccessful.&#34;)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLABase.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, leave_on=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends the serial connection to the laser</p>
<p>:param leave_on:
:returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, leave_on=False):
    &#34;&#34;&#34;Ends the serial connection to the laser

    :param leave_on:
    :returns:

    &#34;&#34;&#34;
    if not self._device.is_open:
        return

    if not leave_on:
        self.disable()

    try:
        self._device.close()
    except AttributeError:
        # When does this error occur?
        # There are a few ways disconnect can be called.
        # 1) It can be called purposefully.
        # 2) It can be called by ending a `with` (ie __exit__)
        # 3) It can be called by exiting a repl or a script ending (ie. __del__).
        pass</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLABase.get_response"><code class="name flex">
<span>def <span class="ident">get_response</span></span>(<span>self, register)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should read from self._device. This should be called</p>
<p>:param register:
:returns: ???</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_response(self, register):
    &#34;&#34;&#34;This function should read from self._device. This should be called

    :param register:
    :returns: ???

    &#34;&#34;&#34;
    # read four bytes
    response = self._device.read(4)

    print(f&#39;response: {response.hex()}&#39;)

    # get the checksum and ... check it.
    checksum = int(response.hex()[0], 16)
    computed_checksum = compute_checksum(response.hex())

    if computed_checksum != checksum:
        raise Exception(f&#39;Communication error expected {checksum} got &#39;
                        + f&#39;{computed_checksum}&#39;)

    status = int(f&#39;{response[0]:08b}&#39;[-2:], 2)
    print(f&#39;status: {status}&#39;)

    try:
        raise self._response_status[status]

    except TypeError:
        # a type error occurs if we try to raise &#34;OK&#34;
        # in this situation we should just pass.
        pass

    except AEAException:
        response = self.read_aea()
        return response

    if register != response[1]:
        raise Exception(&#39;The returned register does not match &#39;
                        + &#39;the register sent to the device. &#39;
                        + f&#39;Got {response[1]} expected {register}.&#39;)

    return response[2:]</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLABase.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, register, data=None, signed=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sends commands to a device.
This function takes the hexstring, turns it into a bytestring,
and writes it to the device.
This function should probably be hidden from the user.</p>
<p>:param device: Should be a Serial object that you can write to.
:param hexstring: a hexstring to send to the device
:returns: nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command(self, register, data=None, signed=False):
    &#34;&#34;&#34;Sends commands to a device.
    This function takes the hexstring, turns it into a bytestring,
    and writes it to the device.
    This function should probably be hidden from the user.

    :param device: Should be a Serial object that you can write to.
    :param hexstring: a hexstring to send to the device
    :returns: nothing
    &#34;&#34;&#34;

    write = (data is not None)

    # convert to register to a bytestring
    register_bytes = register.to_bytes(1, &#39;big&#39;)

    # convert data to bytestring
    if write:
        data_bytes = data.to_bytes(2, &#39;big&#39;, signed=signed)

    else:
        data_bytes = (0).to_bytes(2, &#39;big&#39;)

    # compute the checksum
    checksum = compute_checksum(
        (write.to_bytes(1, &#39;big&#39;) + register_bytes + data_bytes).hex()
    )

    # compute and convery header to bytestring
    header = checksum * 16 + write
    header_bytes = header.to_bytes(1, &#39;big&#39;)

    # form full command and send.
    command = header_bytes + register_bytes + data_bytes
    self._device.write(command)</code></pre>
</details>
</dd>
<dt id="itla.itla.ITLABase.upgrade_firmware"><code class="name flex">
<span>def <span class="ident">upgrade_firmware</span></span>(<span>self, firmware_file)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should update the firmware for the laser.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upgrade_firmware(self, firmware_file):
    &#34;&#34;&#34; This function should update the firmware for the laser.
    &#34;&#34;&#34;

    # STEPS:
    # 1) release
    # 2) set baudrate to 115200
    # 3) disconnect and reconnect at update baudrate
    # 4) send dlconfig signal
    # 5) ????
    # 6) profit
    raise Warning(&#34;this is not implemented yet.&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="itla" href="index.html">itla</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="itla.itla.ITLA" href="#itla.itla.ITLA">ITLA</a></code></h4>
</li>
<li>
<h4><code><a title="itla.itla.ITLABase" href="#itla.itla.ITLABase">ITLABase</a></code></h4>
<ul class="">
<li><code><a title="itla.itla.ITLABase.connect" href="#itla.itla.ITLABase.connect">connect</a></code></li>
<li><code><a title="itla.itla.ITLABase.disconnect" href="#itla.itla.ITLABase.disconnect">disconnect</a></code></li>
<li><code><a title="itla.itla.ITLABase.get_response" href="#itla.itla.ITLABase.get_response">get_response</a></code></li>
<li><code><a title="itla.itla.ITLABase.send_command" href="#itla.itla.ITLABase.send_command">send_command</a></code></li>
<li><code><a title="itla.itla.ITLABase.upgrade_firmware" href="#itla.itla.ITLABase.upgrade_firmware">upgrade_firmware</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>